#!/usr/bin/env node
/**
 * Pro Safe Fixer - Ù†Ø³Ø®Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© ÙˆØ¯Ù‚ÙŠÙ‚Ø© Ø¬Ø¯Ø§Ù‹
 * Ø¥ØµÙ„Ø§Ø­ Ø¢Ù…Ù† ÙˆÙ…ØªØ­ÙƒÙ… ÙÙŠÙ‡ Ù„Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ©
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ProSafeFixer {
  constructor(config = {}) {
    this.config = {
      reportPath: config.reportPath || 'ultimate-scan-report-1756646329709.json',
      testCommand: config.testCommand || 'npm run build',
      dryRun: config.dryRun || false,
      gitBackup: config.gitBackup !== false,
      maxFileSize: config.maxFileSize || 1024 * 1024, // 1MB
      ...config
    };
    
    this.results = [];
    this.stats = {
      total: 0,
      fixed: 0,
      skipped: 0,
      failed: 0,
      manual: 0
    };
    
    this.fixers = {
      'Ù…Ù‚Ø§Ø±Ù†Ø© == Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ===': this.fixEqualityOperator.bind(this),
      'Console statements ÙÙŠ Ø§Ù„ÙƒÙˆØ¯': this.fixConsoleStatements.bind(this),
      'Magic numbers ÙƒØ¨ÙŠØ±Ø©': this.fixMagicNumbers.bind(this),
      'Ø¹Ù…Ù„ÙŠØ© FS Ù…ØªØ²Ø§Ù…Ù†Ø© ØªØ¨Ø·Ø¦ Ø§Ù„Ø®Ø§Ø¯Ù…': this.fixSyncFS.bind(this),
      'Ø§Ø³ØªØ®Ø¯Ø§Ù… any ÙŠÙ„ØºÙŠ type safety': this.fixAnyType.bind(this),
      'XSS: dangerouslySetInnerHTML Ø®Ø·Ø± Ø£Ù…Ù†ÙŠ': this.fixXSS.bind(this),
      'ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø³Ø© Ù…Ø­Ù„ÙŠØ§Ù‹': this.fixLocalStorage.bind(this),
      'Ø­Ù„Ù‚Ø© ØºÙŠØ± Ù…Ø­Ø³Ù†Ø©': this.fixUnoptimizedLoop.bind(this),
      'ØªØ¹Ù‚ÙŠØ¯ Ø¹Ø§Ù„ÙŠ': this.flagComplexity.bind(this)
    };
  }

  async run() {
    console.log('ğŸš€ Ø¨Ø¯Ø¡ Pro Safe Fixer...\n');
    
    try {
      await this.validateEnvironment();
      const report = await this.loadReport();
      await this.createGitBackup();
      
      console.log(`ğŸ“Š ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${report.issues.length} Ù…Ø´ÙƒÙ„Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©\n`);
      
      for (let i = 0; i < report.issues.length; i++) {
        const issue = report.issues[i];
        console.log(`[${i + 1}/${report.issues.length}] Ù…Ø¹Ø§Ù„Ø¬Ø©: ${path.basename(issue.file)}:${issue.line}`);
        
        await this.processIssue(issue);
        
        // ØªØ£Ø®ÙŠØ± ØµØºÙŠØ± Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù…
        await this.sleep(10);
      }
      
      await this.generateReports();
      this.printSummary();
      
    } catch (error) {
      console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„:', error.message);
      process.exit(1);
    }
  }

  async validateEnvironment() {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Node.js Ùˆ Git
    try {
      execSync('node --version', { stdio: 'ignore' });
      execSync('git --version', { stdio: 'ignore' });
    } catch {
      throw new Error('ÙŠØªØ·Ù„Ø¨ Node.js Ùˆ Git');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ package.json
    if (!fs.existsSync('package.json')) {
      console.warn('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ package.json');
    }
  }

  async loadReport() {
    if (!fs.existsSync(this.config.reportPath)) {
      throw new Error(`ØªÙ‚Ø±ÙŠØ± Ø§Ù„ÙØ­Øµ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯: ${this.config.reportPath}`);
    }
    
    const report = JSON.parse(fs.readFileSync(this.config.reportPath, 'utf8'));
    this.stats.total = report.issues?.length || 0;
    
    return report;
  }

  async createGitBackup() {
    if (!this.config.gitBackup) return;
    
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Git
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      
      if (status.trim()) {
        console.log('ğŸ’¾ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ Git...');
        execSync('git add .', { stdio: 'ignore' });
        execSync('git commit -m "Backup before ProSafeFixer"', { stdio: 'ignore' });
      }
      
      console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙÙŠ Git\n');
    } catch (error) {
      console.warn('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Git:', error.message);
    }
  }

  async processIssue(issue) {
    const result = {
      ...issue,
      status: 'unknown',
      fixApplied: false,
      testPassed: false,
      timestamp: new Date().toISOString()
    };

    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ù„Ù
      if (!fs.existsSync(issue.file)) {
        result.status = 'file_not_found';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  â­ï¸ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
        return;
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
      const stats = fs.statSync(issue.file);
      if (stats.size > this.config.maxFileSize) {
        result.status = 'file_too_large';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  â­ï¸ Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹');
        return;
      }

      const originalContent = fs.readFileSync(issue.file, 'utf8');
      const fixedContent = await this.applyFix(originalContent, issue);

      if (fixedContent === originalContent) {
        result.status = 'no_fix_available';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  â­ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¥ØµÙ„Ø§Ø­ Ù…ØªØ§Ø­');
        return;
      }

      result.fixApplied = true;

      // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¬Ø±Ø¨Ø©
      if (!this.config.dryRun) {
        fs.writeFileSync(issue.file, fixedContent, 'utf8');
      }

      // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¥ØµÙ„Ø§Ø­
      const testResult = await this.runTests();
      result.testPassed = testResult;

      if (testResult) {
        result.status = 'fixed';
        this.stats.fixed++;
        console.log('  âœ… ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø¨Ù†Ø¬Ø§Ø­');
      } else {
        result.status = 'test_failed';
        this.stats.failed++;
        
        // Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø¥ØµÙ„Ø§Ø­
        if (!this.config.dryRun) {
          fs.writeFileSync(issue.file, originalContent, 'utf8');
        }
        
        console.log('  âŒ ÙØ´Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± - ØªÙ… Ø§Ù„ØªØ±Ø§Ø¬Ø¹');
      }

    } catch (error) {
      result.status = 'error';
      result.error = error.message;
      this.stats.failed++;
      console.log('  âŒ Ø®Ø·Ø£:', error.message);
    }

    this.results.push(result);
  }

  async applyFix(content, issue) {
    const fixer = this.findFixer(issue.message);
    
    if (!fixer) {
      return content; // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¥ØµÙ„Ø§Ø­ Ù…ØªØ§Ø­
    }

    try {
      return await fixer(content, issue);
    } catch (error) {
      console.log(`  âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥ØµÙ„Ø§Ø­: ${error.message}`);
      return content;
    }
  }

  findFixer(message) {
    for (const [pattern, fixer] of Object.entries(this.fixers)) {
      if (message.includes(pattern)) {
        return fixer;
      }
    }
    return null;
  }

  // Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ØºÙ„ Ø§Ù„Ù…Ø³Ø§ÙˆØ§Ø©
  fixEqualityOperator(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      // Ø¥ØµÙ„Ø§Ø­ Ø¯Ù‚ÙŠÙ‚ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯
      lines[lineIndex] = lines[lineIndex].replace(/([^=!])==([^=])/g, '$1===$2');
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ console statements
  fixConsoleStatements(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      // Ø¥Ø²Ø§Ù„Ø© console.log ÙÙ‚Ø·ØŒ Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù€ console.error Ùˆ console.warn
      if (line.includes('console.log')) {
        lines[lineIndex] = line.replace(/console\.log\([^)]*\);?/g, '// TODO: Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ù€ logger');
      }
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ Magic Numbers
  fixMagicNumbers(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ø±Ù‚Ø§Ù… ÙƒØ¨ÙŠØ±Ø© (Ø£ÙƒØ«Ø± Ù…Ù† 100)
      const magicNumberRegex = /\b(\d{3,})\b/g;
      const matches = line.match(magicNumberRegex);
      
      if (matches) {
        let newLine = line;
        matches.forEach(num => {
          const constName = `CONST_${num}`;
          newLine = newLine.replace(new RegExp(`\\b${num}\\b`, 'g'), constName);
        });
        
        lines[lineIndex] = newLine;
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø«Ø§Ø¨Øª ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù
        const constDeclaration = matches.map(num => 
          `const CONST_${num} = ${num}; // TODO: Ø§Ø®ØªØ± Ø§Ø³Ù…Ø§Ù‹ ÙˆØµÙÙŠØ§Ù‹`
        ).join('\n');
        
        lines.unshift(constDeclaration);
      }
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø©
  fixSyncFS(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      let line = lines[lineIndex];
      
      // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø© Ø¨ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù†Ø©
      line = line.replace(/fs\.readFileSync/g, 'await fs.promises.readFile');
      line = line.replace(/fs\.writeFileSync/g, 'await fs.promises.writeFile');
      line = line.replace(/fs\.existsSync/g, 'await fs.promises.access');
      
      lines[lineIndex] = line;
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ Ù†ÙˆØ¹ any
  fixAnyType(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      lines[lineIndex] = lines[lineIndex].replace(
        /:\s*any\b/g, 
        ': unknown // TODO: Ø­Ø¯Ø¯ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨'
      );
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ XSS
  fixXSS(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      if (line.includes('dangerouslySetInnerHTML')) {
        lines[lineIndex] = '// TODO: Ø§Ø³ØªØ®Ø¯Ù… DOMPurify Ø£Ùˆ Ù…ÙƒØªØ¨Ø© ØªÙ†Ø¸ÙŠÙ HTML Ø¢Ù…Ù†Ø©\n' + line;
      }
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ localStorage
  fixLocalStorage(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      if (line.includes('localStorage')) {
        lines[lineIndex] = '// TODO: Ø´ÙÙ‘Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ®Ø²ÙŠÙ†\n' + line;
      }
    }
    
    return lines.join('\n');
  }

  // Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø­Ù„Ù‚Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø­Ø³Ù†Ø©
  fixUnoptimizedLoop(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      let line = lines[lineIndex];
      
      // Ø¥ØµÙ„Ø§Ø­ for loops
      line = line.replace(
        /for\s*\(\s*let\s+(\w+)\s*=\s*0;\s*\1\s*<\s*(\w+)\.length/g,
        'for (let $1 = 0, len = $2.length; $1 < len'
      );
      
      lines[lineIndex] = line;
    }
    
    return lines.join('\n');
  }

  // ÙˆØ¶Ø¹ Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ø¹Ø§Ù„ÙŠ
  flagComplexity(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      lines[lineIndex] = '// TODO: Ù‚Ø³Ù‘Ù… Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø¯ÙˆØ§Ù„ Ø£ØµØºØ±\n' + lines[lineIndex];
    }
    
    return lines.join('\n');
  }

  async runTests() {
    if (!this.config.testCommand) return true;
    
    try {
      execSync(this.config.testCommand, { 
        stdio: 'ignore',
        timeout: 30000 // 30 Ø«Ø§Ù†ÙŠØ© timeout
      });
      return true;
    } catch {
      return false;
    }
  }

  async generateReports() {
    // ØªÙ‚Ø±ÙŠØ± JSON
    const jsonReport = {
      timestamp: new Date().toISOString(),
      config: this.config,
      stats: this.stats,
      results: this.results
    };
    
    fs.writeFileSync('fix-report.json', JSON.stringify(jsonReport, null, 2));
    
    // ØªÙ‚Ø±ÙŠØ± HTML
    await this.generateHTMLReport();
    
    console.log('\nğŸ“„ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±:');
    console.log('  - fix-report.json');
    console.log('  - fix-report.html');
  }

  async generateHTMLReport() {
    const rows = this.results.map(result => {
      const statusColor = {
        'fixed': '#28a745',
        'test_failed': '#dc3545',
        'no_fix_available': '#6c757d',
        'file_not_found': '#ffc107',
        'error': '#dc3545'
      }[result.status] || '#6c757d';
      
      return `
        <tr>
          <td>${path.basename(result.file)}</td>
          <td>${result.line}</td>
          <td>${result.category}</td>
          <td>${result.severity}</td>
          <td>${result.message}</td>
          <td style="color: ${statusColor}; font-weight: bold;">${result.status}</td>
        </tr>
      `;
    }).join('');

    const html = `
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¥ØµÙ„Ø§Ø­ - Pro Safe Fixer</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .stats { display: flex; gap: 20px; margin-bottom: 20px; }
        .stat-card { background: #fff; border: 1px solid #dee2e6; padding: 15px; border-radius: 8px; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #dee2e6; padding: 12px; text-align: right; }
        th { background: #e9ecef; font-weight: bold; }
        tr:nth-child(even) { background: #f8f9fa; }
        .fixed { color: #28a745; }
        .failed { color: #dc3545; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ”§ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¥ØµÙ„Ø§Ø­ - Pro Safe Fixer</h1>
        <p>ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙÙŠ: ${new Date().toLocaleString('ar-SA')}</p>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <h3>${this.stats.total}</h3>
            <p>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„</p>
        </div>
        <div class="stat-card">
            <h3 class="fixed">${this.stats.fixed}</h3>
            <p>ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­</p>
        </div>
        <div class="stat-card">
            <h3 class="failed">${this.stats.failed}</h3>
            <p>ÙØ´Ù„ Ø§Ù„Ø¥ØµÙ„Ø§Ø­</p>
        </div>
        <div class="stat-card">
            <h3>${this.stats.skipped}</h3>
            <p>ØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ</p>
        </div>
    </div>
    
    <table>
        <thead>
            <tr>
                <th>Ø§Ù„Ù…Ù„Ù</th>
                <th>Ø§Ù„Ø³Ø·Ø±</th>
                <th>Ø§Ù„ÙØ¦Ø©</th>
                <th>Ø§Ù„Ø®Ø·ÙˆØ±Ø©</th>
                <th>Ø§Ù„ÙˆØµÙ</th>
                <th>Ø§Ù„Ø­Ø§Ù„Ø©</th>
            </tr>
        </thead>
        <tbody>
            ${rows}
        </tbody>
    </table>
</body>
</html>
    `;
    
    fs.writeFileSync('fix-report.html', html);
  }

  printSummary() {
    console.log('\nğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:');
    console.log(`  ğŸ“ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„: ${this.stats.total}`);
    console.log(`  âœ… ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­: ${this.stats.fixed}`);
    console.log(`  âŒ ÙØ´Ù„ Ø§Ù„Ø¥ØµÙ„Ø§Ø­: ${this.stats.failed}`);
    console.log(`  â­ï¸ ØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ: ${this.stats.skipped}`);
    
    const successRate = this.stats.total > 0 ? 
      ((this.stats.fixed / this.stats.total) * 100).toFixed(1) : 0;
    
    console.log(`  ğŸ“ˆ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ø¬Ø§Ø­: ${successRate}%`);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª
if (require.main === module) {
  const args = process.argv.slice(2);
  const config = {};
  
  // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--dry-run':
        config.dryRun = true;
        break;
      case '--no-git':
        config.gitBackup = false;
        break;
      case '--report':
        config.reportPath = args[++i];
        break;
      case '--test':
        config.testCommand = args[++i];
        break;
    }
  }
  
  const fixer = new ProSafeFixer(config);
  fixer.run().catch(console.error);
}

module.exports = ProSafeFixer;