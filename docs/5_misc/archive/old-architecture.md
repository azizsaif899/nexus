# البنية الهندسية (Architecture) - مشروع G-Assistant

**الإصدار:** 2.0 (مدمج ومطور)
**الحالة:** ساري المفعول

---

## 1.0 نظرة عامة

يوضح هذا المستند البنية الهندسية لمشروع `g-assistant`. تم تصميم النظام بشكل معياري (Modular) لضمان فصل المسؤوليات، تسهيل الصيانة، وتجنب المشاكل الشائعة مثل التبعيات الدائرية. تعتمد الهندسة على مبدأ انعكاس التبعية واستخدام الوسطاء (Mediators) لفك الارتباط بين المكونات.

---

## 2.0 المكونات الرئيسية (Core Components)

تتكون البنية من عدة طبقات مرتبة رقميًا، تمثل تدفق التحكم من واجهة المستخدم إلى الأنظمة الأساسية.

*   **`10_ui/` (طبقة الواجهة):** مسؤولة عن كل تفاعل مع المستخدم داخل Google Workspace. تستقبل المدخلات وترسلها للمعالجة، وتعرض النتائج النهائية.
*   **`20_ai/` (طبقة الذكاء الاصطناعي):** العقل المدبر للنظام. تحتوي على المكونات التالية:
    *   **`Orchestrator` (المنسق):** يستقبل الطلبات من الواجهة ويحلل النية (Intent) لتحديد الخطوة التالية.
    *   **`AI Core` (النواة):** تتفاعل مباشرة مع Gemini API.
    *   **`Context/Memory` (الذاكرة):** تدير سياق المحادثة.
*   **`25_ai_agents/` (طبقة الوكلاء):** وحدات منطقية متخصصة. كل وكيل مسؤول عن مجال معين (e.g., `Developer Agent`).
*   **`30_tools/` (طبقة الأدوات):** مجموعة من الوظائف العملية التي يمكن للوكلاء استدعاؤها لتنفيذ مهام محددة (e.g., `Sheets Tool`, `Code Review Tool`).
*   **`90_System/` (طبقة النظام):** توفر خدمات أساسية مثل إدارة التخزين، معالجة الأحداث، والتحقق من الصحة.

---

## 3.0 تدفق البيانات النموذجي (Typical Data Flow)

1.  **الطلب (Request):** المستخدم يقدم أمرًا عبر الواجهة (`10_ui`).
2.  **التوجيه (Routing):** الواجهة تستدعي المنسق (`Orchestrator`) في طبقة الذكاء الاصطناعي (`20_ai`).
3.  **التحليل والتفويض (Analysis & Delegation):** المنسق يحلل الطلب ويفوضه إلى الوكيل المناسب في (`25_ai_agents`).
4.  **تنفيذ الأداة (Tool Execution):** الوكيل يقرر أنه بحاجة إلى أداة لتنفيذ الطلب، فيطلبها من كتالوج الأدوات (`30_tools`).
5.  **التوليد (Generation):** بعد تنفيذ الأداة والحصول على البيانات، يتم إرسال طلب إلى Gemini API لتوليد استجابة لغوية.
6.  **الاستجابة (Response):** يتم إرجاع الاستجابة النهائية إلى الواجهة لعرضها للمستخدم.

---

## 4.0 فلسفة التصميم والمبادئ المعمارية

الهدف الأساسي هو تجنب الاعتماديات المباشرة والمعقدة بين الوحدات. لتحقيق ذلك، نعتمد على المبادئ التالية:

### 4.1 مبدأ انعكاس التبعية عبر الوسطاء (Dependency Inversion via Mediators)

بدلاً من أن تعتمد الوحدات عالية المستوى (مثل `AI Core`) على الوحدات منخفضة المستوى (مثل `Tools`) مباشرة، يعتمد كلاهما على "وسيط" أو "كتالوج".

*   **السيناريو الخاطئ:** `AI.Core` يستدعي `Tools.Developer` مباشرة.
*   **الحل الصحيح (المطبق في المشروع):**
    1.  `AI.Core` لا يعرف شيئًا عن الأدوات المتاحة. هو فقط يطلب أداة من `Tools.Catalog`.
    2.  كل أداة (مثل `Tools.Developer`) تسجل نفسها وقدراتها في `Tools.Catalog` عند بدء تشغيل النظام.
    3.  بهذه الطريقة، `AI.Core` و `Tools.Developer` كلاهما يعتمد على `Tools.Catalog`، مما يكسر الاعتماد المباشر.

### 4.2 التهيئة الخارجية (External Initialization)

لمنع الحلقات التي قد تنشأ أثناء إعداد النظام (e.g., `Config` يحتاج `Logger` و `Logger` يحتاج `Config`)، يتم استخدام دالة تهيئة خارجية (موجودة في `00_initializer.gs`). هذه الدالة مسؤولة عن:
1.  تحميل جميع الوحدات بشكل مستقل.
2.  تنسيق عملية تسجيل الوحدات في الكتالوجات الخاصة بها.
3.  التأكد من أن النظام بأكمله جاهز للعمل قبل استقبال أي طلبات.

### 4.3 الاتصال القائم على الأحداث (Event-Based Communication)

في بعض الحالات المتقدمة، يمكن استخدام نظام أحداث بسيط لفك الارتباط بشكل كامل. بدلاً من الاستدعاء المباشر، يمكن لمكون أن يطلق حدثًا (e.g., `prompt_received`)، وتقوم المكونات الأخرى بالاستماع والاستجابة لهذا الحدث.

---

## 5.0 رسم تخطيطي (Diagram)

(يجب إضافة رسم تخطيطي هنا يوضح تدفق البيانات والمكونات الرئيسية ومبدأ الوسيط)

![Architecture Diagram Placeholder](https://i.imgur.com/your-diagram-placeholder.png)
