// import { EventBus } from '@azizsys/core-logic';
// import { PredictionModels } from '@azizsys/ml-core';

// Mock EventBus and PredictionModels for now
class MockEventBus {
  static getInstance() { return new MockEventBus(); }
  emit(event: string, data: any) { // Removed console.log }
}

export class MockPredictionModels {
  async predictRevenue(config: any) {
    return { value: config.features[0] * 1.1 }; // Mock prediction
  }
}

export interface WhatIfScenario {
  id: string;
  name: string;
  description: string;
  baselineMetrics: Record<string, number>;
  changes: Record<string, number>;
  projectedOutcomes: WhatIfOutcome[];
  confidence: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
}

export interface WhatIfOutcome {
  metric: string;
  baselineValue: number;
  projectedValue: number;
  absoluteChange: number;
  percentageChange: number;
  impact: 'positive' | 'negative' | 'neutral';
}

export interface WhatIfAnalysisRequest {
  baselineData: Record<string, number>;
  scenarios: Array<{
    name: string;
    changes: Record<string, number>;
  }>;
  timeframe: number; // months
  analysisType: 'financial' | 'operational' | 'strategic' | 'comprehensive';
}

export class WhatIfAnalysis {
  private eventBus: MockEventBus;
  private predictionModels: MockPredictionModels;

  constructor() {
    this.eventBus = MockEventBus.getInstance();
    this.predictionModels = new MockPredictionModels();
  }

  async analyzeScenarios(request: WhatIfAnalysisRequest): Promise<WhatIfScenario[]> {
    const scenarios: WhatIfScenario[] = [];

    for (const scenarioConfig of request.scenarios) {
      const scenario = await this.analyzeScenario({
        ...scenarioConfig,
        baselineData: request.baselineData,
        timeframe: request.timeframe,
        analysisType: request.analysisType
      });
      scenarios.push(scenario);
    }

    this.eventBus.emit('whatif:analysis:completed', { scenarios, request });
    return scenarios;
  }

  private async analyzeScenario(config: {
    name: string;
    changes: Record<string, number>;
    baselineData: Record<string, number>;
    timeframe: number;
    analysisType: string;
  }): Promise<WhatIfScenario> {
    const modifiedData = { ...config.baselineData };
    
    // Apply changes to baseline data
    Object.entries(config.changes).forEach(([key, change]) => {
      if (modifiedData[key] !== undefined) {
        modifiedData[key] = modifiedData[key] * (1 + change / 100);
      }
    });

    const projectedOutcomes = await this.calculateOutcomes(
      config.baselineData,
      modifiedData,
      config.timeframe
    );

    const confidence = this.calculateConfidence(config.changes, projectedOutcomes);
    const riskLevel = this.assessRiskLevel(projectedOutcomes);

    return {
      id: `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: config.name,
      description: this.generateDescription(config.changes),
      baselineMetrics: config.baselineData,
      changes: config.changes,
      projectedOutcomes,
      confidence,
      riskLevel
    };
  }

  private async calculateOutcomes(
    baseline: Record<string, number>,
    modified: Record<string, number>,
    timeframe: number
  ): Promise<WhatIfOutcome[]> {
    const outcomes: WhatIfOutcome[] = [];

    for (const [metric, baselineValue] of Object.entries(baseline)) {
      const modifiedValue = modified[metric] || baselineValue;
      
      // Use prediction models for more accurate projections
      const features = Object.values(modified);
      const prediction = await this.predictionModels.predictRevenue({
        features,
        timeframe,
        context: { baseline, modified }
      });

      const projectedValue = prediction.value;
      const absoluteChange = projectedValue - baselineValue;
      const percentageChange = (absoluteChange / baselineValue) * 100;

      outcomes.push({
        metric,
        baselineValue,
        projectedValue,
        absoluteChange,
        percentageChange,
        impact: this.determineImpact(percentageChange)
      });
    }

    return outcomes;
  }

  private calculateConfidence(
    changes: Record<string, number>,
    outcomes: WhatIfOutcome[]
  ): number {
    // Base confidence starts high for small changes
    const changesMagnitude = Object.values(changes)
      .reduce((sum, change) => sum + Math.abs(change), 0) / Object.keys(changes).length;

    let baseConfidence = Math.max(0.3, 1 - (changesMagnitude / 100));

    // Adjust based on outcome consistency
    const outcomeVariance = this.calculateOutcomeVariance(outcomes);
    const consistencyFactor = Math.max(0.5, 1 - outcomeVariance);

    return Math.min(0.95, baseConfidence * consistencyFactor);
  }

  private calculateOutcomeVariance(outcomes: WhatIfOutcome[]): number {
    const changes = outcomes.map(o => Math.abs(o.percentageChange));
    const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
    const variance = changes.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / changes.length;
    return Math.sqrt(variance) / 100; // Normalize to 0-1 range
  }

  private assessRiskLevel(outcomes: WhatIfOutcome[]): 'low' | 'medium' | 'high' | 'critical' {
    const negativeOutcomes = outcomes.filter(o => o.impact === 'negative');
    const maxNegativeChange = Math.max(...negativeOutcomes.map(o => Math.abs(o.percentageChange)), 0);

    if (maxNegativeChange > 50) return 'critical';
    if (maxNegativeChange > 25) return 'high';
    if (maxNegativeChange > 10) return 'medium';
    return 'low';
  }

  private determineImpact(percentageChange: number): 'positive' | 'negative' | 'neutral' {
    if (Math.abs(percentageChange) < 2) return 'neutral';
    return percentageChange > 0 ? 'positive' : 'negative';
  }

  private generateDescription(changes: Record<string, number>): string {
    const changeDescriptions = Object.entries(changes).map(([key, value]) => {
      const direction = value > 0 ? 'increase' : 'decrease';
      return `${Math.abs(value)}% ${direction} in ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}`;
    });

    return `Scenario with ${changeDescriptions.join(', ')}`;
  }

  async compareScenarios(scenarios: WhatIfScenario[]): Promise<{
    bestScenario: WhatIfScenario;
    worstScenario: WhatIfScenario;
    comparison: Array<{
      metric: string;
      scenarios: Array<{
        name: string;
        value: number;
        rank: number;
      }>;
    }>;
  }> {
    // Calculate overall score for each scenario
    const scoredScenarios = scenarios.map(scenario => {
      const positiveOutcomes = scenario.projectedOutcomes.filter(o => o.impact === 'positive');
      const score = positiveOutcomes.reduce((sum, outcome) => sum + outcome.percentageChange, 0);
      return { scenario, score };
    });

    const bestScenario = scoredScenarios.reduce((best, current) => 
      current.score > best.score ? current : best
    ).scenario;

    const worstScenario = scoredScenarios.reduce((worst, current) => 
      current.score < worst.score ? current : worst
    ).scenario;

    // Create comparison matrix
    const allMetrics = [...new Set(scenarios.flatMap(s => s.projectedOutcomes.map(o => o.metric)))];
    const comparison = allMetrics.map(metric => {
      const scenarioValues = scenarios.map(scenario => {
        const outcome = scenario.projectedOutcomes.find(o => o.metric === metric);
        return {
          name: scenario.name,
          value: outcome?.projectedValue || 0
        };
      }).sort((a, b) => b.value - a.value);

      return {
        metric,
        scenarios: scenarioValues.map((sv, index) => ({
          ...sv,
          rank: index + 1
        }))
      };
    });

    return { bestScenario, worstScenario, comparison };
  }
}