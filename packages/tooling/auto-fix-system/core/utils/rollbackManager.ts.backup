import * as fs from 'fs';
import * as path from 'path';

export class RollbackManager {
  private static backups = new Map<string, string>();

  // إنشاء نسخة احتياطية
  static async createBackup(filePath: string): Promise<string> {
    try {
      const timestamp = Date.now();
      const backupPath = `${filePath}.backup.${timestamp}`;
      
      if (/* PERFORMANCE: Consider using async version */ fs.existsSync(filePath)) {
        /* PERFORMANCE: Consider using async version */ fs.copyFileSync(filePath, backupPath);
        this.backups.set(filePath, backupPath);
        // Removed console.log
        return backupPath;
      }
      
      throw new Error(`File not found: ${filePath}`);
    } catch (error) {
      console.error(`❌ Backup failed for ${filePath}:`, error);
      throw error;
    }
  }

  // التراجع التلقائي
  static async rollbackOnFailure(filePath: string, reason = 'Execution failed'): Promise<void> {
    try {
      const backupPath = this.backups.get(filePath);
      
      if (!backupPath || !/* PERFORMANCE: Consider using async version */ fs.existsSync(backupPath)) {
        throw new Error(`No backup found for ${filePath}`);
      }

      // استعادة من النسخة الاحتياطية
      /* PERFORMANCE: Consider using async version */ fs.copyFileSync(backupPath, filePath);
      // Removed console.log
      
      // تنظيف النسخة الاحتياطية
      this.cleanupBackup(filePath);
      
    } catch (error) {
      console.error(`❌ Rollback failed for ${filePath}:`, error);
      throw error;
    }
  }

  // تنظيف النسخة الاحتياطية
  static cleanupBackup(filePath: string): void {
    try {
      const backupPath = this.backups.get(filePath);
      if (backupPath && /* PERFORMANCE: Consider using async version */ fs.existsSync(backupPath)) {
        /* PERFORMANCE: Consider using async version */ fs.unlinkSync(backupPath);
        this.backups.delete(filePath);
        // Removed console.log
      }
    } catch (error) {
      console.warn(`⚠️ Cleanup failed for ${filePath}:`, error);
    }
  }

  // التحقق من وجود نسخة احتياطية
  static hasBackup(filePath: string): boolean {
    const backupPath = this.backups.get(filePath);
    return backupPath ? /* PERFORMANCE: Consider using async version */ fs.existsSync(backupPath) : false;
  }

  // الحصول على مسار النسخة الاحتياطية
  static getBackupPath(filePath: string): string | undefined {
    return this.backups.get(filePath);
  }
}